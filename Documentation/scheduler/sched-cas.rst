.. SPDX-License-Identifier: GPL-2.0+

=========================
Capacity-Aware Scheduling
=========================

Scheduling load balancing on Asymmetric Multiprocessor systems was improved
through the introduction of Capacity-Aware Scheduling. It identifies the
most efficient CPU to assign a task based on its capacity. This capacity
may be asymmetric due to heterogeneous computing architecture such
as ARM big.LITTLE. Scheduler gets information about asymmetric capacities
when the scheduler domain hierarchy is built using build_sched_domains().
CPU capacities are provided to the scheduler topology code through the
architecture specific implementation of the arch_scale_cpu_capacity().
The SD_ASYM_CPUCAPACITY flag is set by the scheduler topology for a domain
in the hierarchy where all CPU capacities are visible for any cpu's point
of view on asymmetric CPU capacity systems. The scheduler can then take
capacity asymmetry into account when load balancing.

Initial CPU capacities are derived from the Device Tree and CPU frequency.
For RISC-V & ARM64 it is done in drivers/base/arch_topology.c. A cpu-map
device tree is parsed to obtain the cpu topology and the initial CPU capacity
is set using the CPUFreq subsystem. A callback is registered to the CPUFreq
subsystem to rebuild sched_domains once the CPUFreq is loaded, which is when
a complete view of the capacities of the CPUs (which is a mix of Âµarch and
frequencies) is available.

Asymmetric CPU capacity information is used in

* Energy Aware Scheduling: The scheduler is  able to predict the impact of
  its decisions on the energy consumed by CPUs. Described in :doc:`sched-energy` .
* Optimized task wakeup load balancing by finding idle CPU with enough capacity.

The different scheduler classes asymmetric use the Asymmetric CPU capacity
information differently.

CFS Capacity Awareness
======================

Used to identify misfit tasks:
A load intensive task on a CPU which doesn't meet its compute demand is
identified as a misfit task. 'Misfit' tasks are migrated to CPUs with
higher compute capacity to ensure better throughput. CFS frequently updates
the misfit status of the current task by comparing its utilization vs the
CPU capacity using task_fits_capacity(). If the utilization is more than the
CPU capacity the calculated misfit load is updated to the runqueue
rq->misfit_task_load. This misfit load is then checked by the load
balancing operations to migrate the task to a CPU of higher capacity.

Modified wakeup logic to support DynamIQ systems:
When the scheduler class calls select_task_rq_fair to select a runqueue for
a waking task, load balancing is performed by selecting the idlest CPU in
the idlest group, or under certain conditions an idle sibling CPU if the
domain has SD_WAKE_AFFINE set. In DynamIQ systems Last Level Cache (LLC)
domain of a CPU spans all CPUs in the system. This may include CPU's of
different capacities. So in select_idle_sibling() an idle sibling is picked
based on CPU capacity for asymmetric CPU capacity systems and for symmetric
systems use LLC domain is used. The policy is to pick the first idle CPU
which is big enough for the task (task_util * margin < cpu_capacity).
If no idle CPU is big enough, the idle CPU with the highest capacity is
picked. For asymmetric CPU capacity systems select_idle_sibling() operates
on the sd_asym_cpucapacity sched_domain pointer, which is guaranteed to span
all known CPU capacities in the system. This works for both "legacy"
big.LITTLE (LITTLEs & bigs split at MC, joined at DIE) and for newer
DynamIQ systems (e.g. LITTLEs and bigs in the same MC domain).


RT Capacity Awareness
=====================

Since RT tasks doesn't have a per task utilization signal RT tasks uses uclamp
to guarantee a minimum performance point. Utilization clamping is a mechanism
which allows to "clamp" (i.e. filter) the utilization generated by RT and
FAIR tasks within a range defined by user-space. It exposes to user-space a
new set of per-task attributes the scheduler can use as hints about the
expected/required utilization for a task. RT is made capacity aware
by ensuring that the capacity of the CPU is >= uclamp_min value. This check
is done in the rt_task_fits_capacity()

DL Capacity Awareness
=====================

TBD









